//===- SemanticsEmitter.cpp - Generate a Instruction Set Desc. ------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This tablegen backend is responsible for emitting a description of the
// instruction-level semantics of the target instruction set.
//
//===----------------------------------------------------------------------===//

#include "CodeGenDAGPatterns.h"
#include "CodeGenTarget.h"
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/Signals.h"
#include "llvm/TableGen/Record.h"
#include "llvm/TableGen/TableGenBackend.h"
#include <algorithm>

using namespace llvm;

namespace {

/// The target we're generating semantics for: keeps around some useful
/// references to the parsed CodeGen target description, and some generation
/// variables.
class SemanticsTarget {
public:
  RecordKeeper &Records;
  CodeGenDAGPatterns CGPatterns;
  CodeGenTarget &CGTarget;

  /// Keep track of the equivalence between target-specific SDNodes and
  /// their target-independent equivalent, as described in definitions
  /// derived of the SDNodeEquiv class.
  typedef std::map<Record *, Record *> SDNodeEquivMap;
  SDNodeEquivMap SDNodeEquiv;

  /// Unique constant integers, and keep track of their index in a table.
  /// This is done so that the generated semantics table is an unsigned[],
  /// with uint64_t constants only being an unsigned index to this table.
  typedef std::map<uint64_t, unsigned> ConstantIdxMap;
  ConstantIdxMap ConstantIdx;
  unsigned CurConstIdx;

  SemanticsTarget(RecordKeeper &Records);
};

/// The semantics of a single SDNode, as an operation, taking operands and
/// producing typed results.
class NodeSemantics {
public:
  /// The opcode for this operation: either an ISD (for SDNodes), or DCINS
  /// (for other operations, like manipulating operands, registers, etc..)
  /// opcode.
  std::string Opcode;

  /// The types of each result generated by this operation.
  std::vector<MVT::SimpleValueType> Types;

  /// All the operands of this instruction.
  std::vector<std::string> Operands;

  void addOperand(StringRef Op) { Operands.push_back(Op); }
};

class InstSemantics {
public:
  std::vector<NodeSemantics> Semantics;

  /// Construct semantics for the pattern \p TP, for instruction \p CGI.
  InstSemantics(SemanticsTarget &Target, const CodeGenInstruction &CGI,
                const TreePattern &TP);
  /// Default constructor for empty semantics.
  InstSemantics();
};

/// The core of the Pattern->Semantics translation, the "flattener".
class Flattener {
public:
  Flattener(SemanticsTarget &Target, const CodeGenInstruction &CGI,
            InstSemantics &I)
      : Target(Target), CGI(CGI), I(I), CurDefNo(0) {}
  

private:
  SemanticsTarget &Target;
  const CodeGenInstruction &CGI;
  InstSemantics &I;

  typedef SmallPtrSet<Record *, 1> ImplicitRegSet;
  ImplicitRegSet EliminatedImplicitRegs;

  typedef StringMap<unsigned> NameToOperandMap;
  NameToOperandMap OperandByName;

  unsigned CurDefNo;

  /// Get the CodeGenInstruction OperandInfo for \p Name.
  const CGIOperandList::OperandInfo *getNamedOperand(StringRef Name) {
    if (Name.empty())
      return 0;
    // FIXME: This is the slow, stupid, simple way.
    for (unsigned OI = 0, OE = CGI.Operands.size(); OI != OE; ++OI) {
      if (Name == CGI.Operands[OI].Name)
        return &CGI.Operands[OI];
    }
    return 0;
  }

  /// Set the types of \p NS to what was inferred for \p TPN, or MVT::isVoid if
  /// the node has no result.
  void setNSTypeFromNode(NodeSemantics &NS, const TreePatternNode *TPN) {
    errs()<<"setNsTypeFromNode "<<TPN->getName()<<"\n";
    if (TPN->getNumTypes()) {
      errs()<<"tpn numTypes "<<TPN->getNumTypes()<<"\n";
      for (unsigned i = 0, e = TPN->getNumTypes(); i != e; ++i){
         NS.Types.push_back(TPN->getSimpleType(i));
         errs()<<"the type is a tpn type"<<TPN->getSimpleType(i)<<"\n";
         errs()<<"the type is a tpn type"<<TPN->getExtType(i)<<"\n";
        if(TPN->getSimpleType(i)==192){
             errs()<<"the type is a special type\n";
        }
      }
       
    } else {
      errs()<<"ns type is isVoid \n";
      NS.Types.push_back(MVT::isVoid);
    }
  }

  /// Add the operation \p NS to the instruction semantics, keeping track of
  /// the defined values.
  void addSemantics(const NodeSemantics &NS) {
    for (unsigned i = 0, e = NS.Types.size(); i != e; ++i) {
      if (NS.Types[i] != MVT::isVoid)
        ++CurDefNo;
    }
    I.Semantics.push_back(NS);
  }

  /// Add the results of \p Prev as operands to \p NS.
  void addResOperand(NodeSemantics &NS, const NodeSemantics &Prev) {
   // if()
    //errs()<<"at start of addResOperand :"<<Prev.Opcode<<"\n";

    errs()<<"prev.Type.size : "<<Prev.Types.size()<<"\n";
    errs()<<"cur def no :"<<CurDefNo<<"\n";
    unsigned FirstDefNo = CurDefNo - (Prev.Types.size() - 1);
    errs()<<"frst Def No:"<<FirstDefNo<<"\n";
    errs()<<"prev.Type.size : "<<Prev.Types.size()<<"\n";
    for (unsigned i = 0, e = Prev.Types.size(); i != e; ++i) {
      if (Prev.Types[i] != MVT::isVoid)
      {
          NS.addOperand(utostr(FirstDefNo + i));
      }
        
    }
    errs()<<"after add operand\n";
    addSemantics(Prev);
    errs()<<"add semantics\n";
  }

  /// Make node semantics from an Operand patern:
  /// - if \p TPN is a RegisterClass or a RegisterOperand, generate:
  ///     DCINS::GET_RC, <inferred type>, <MIOperandNo of the Operand>
  /// - if \p TPN is an Operand, generate:
  ///     DCINS::CUSTOM_OP, <inferred types>,
  ///       <the Operand type as a Target::OpTypes:: enum value>,
  ///       <MIOperandNo of the first MI operand for this Operand>
  /// - if \p TPN is an OPERAND_IMMEDIATE Operand, generate:
  ///     DCINS::CONSTANT_OP, <inferred type>, <MIOperandNo of the Operand>
  ///
  /// Also, add the values defined by this node as operands to \p Parent.
  ///
  void flattenOperand(const TreePatternNode *TPN, NodeSemantics *Parent,
                      const CGIOperandList::OperandInfo *OpInfo) {
    errs()<<"start to flatten operand\n";
    Record *OpRec = OpInfo->Rec;
    errs()<<"OpRec : "<<OpRec->getName()<<"\n";
    NodeSemantics Op;
    setNSTypeFromNode(Op, TPN);

    // RegisterOperands are the same thing as RegisterClasses.
    if (OpRec->isSubClassOf("RegisterOperand"))
      OpRec = OpRec->getValueAsDef("RegClass");

    if (OpRec->isSubClassOf("Operand")) {
      if (OpInfo->OperandType == "OPERAND_IMMEDIATE") {
        Op.Opcode = "DCINS::CONSTANT_OP";
      } else {
        Op.Opcode = "DCINS::CUSTOM_OP";
        std::string CGI_NameSpace;
        //StringRef* OP_TYPE = new StringRef("::OpType::");
        CGI_NameSpace = CGI.Namespace.str() + std::string("::OpType::") + OpRec->getName().str() ;
       // Op.addOperand((StringRef)CGI_NameSpace + "::OpTypes::" + OpRec->getName());
        Op.addOperand(CGI_NameSpace);
        NameToOperandMap::iterator It = OperandByName.find(OpInfo->Name);
        if (It == OperandByName.end()) {
          OperandByName[OpInfo->Name] = CurDefNo;
        } else {
          // If we already found it, no need to generate the operation again.
          Parent->addOperand(utostr(It->getValue()));
          return;
        }
      }
    } else if (OpRec->isSubClassOf("RegisterClass")) {
      Op.Opcode = "DCINS::GET_RC";
    } else {
      llvm_unreachable("Unknown operand type");
    }
    Op.addOperand(utostr(OpInfo->MIOperandNo));
    addResOperand(*Parent, Op);
  }

  /// Make node semantics from a leaf pattern:
  /// - if \p TPN is an explicit Register, generate:
  ///     DCINS::GET_REG, <inferred type>, Target::RegName
  /// - if \p TPN is a compile-time constant, generate:
  ///     DCINS::MOV_CONSTANT, <inferred type>, <Constant index>
  ///   The constant index points in an uint64_t array, where all compile-time
  ///   constants are uniqued (so that the semantics array remains unsigned[].)
  ///
  void flattenLeaf(const TreePatternNode *TPN, NodeSemantics *Parent) {
    DefInit *OpDef = dyn_cast<DefInit>(TPN->getLeafValue());

    if (OpDef == 0) {
      errs()<<"OpDef == 0\n";
      IntInit *OpInt = cast<IntInit>(TPN->getLeafValue());
      NodeSemantics Mov;
      setNSTypeFromNode(Mov, TPN);
      Mov.Opcode = "DCINS::MOV_CONSTANT";
      unsigned &Idx = Target.ConstantIdx[OpInt->getValue()];
      errs()<<"OpInt->getvalue : "<<OpInt->getValue()<<"\n";

      if (Idx == 0)
        Idx = Target.CurConstIdx++;
      Mov.addOperand(utostr(Idx));
      addResOperand(*Parent, Mov);
      return;
    }

    Record *OpRec = OpDef->getDef();
    NodeSemantics Op;
    setNSTypeFromNode(Op, TPN);

    errs()<<"OpRec : "<<OpRec->getName()<<"\n";
    
    if (OpRec->isSubClassOf("Register")) {
      errs()<<"is sub class of register\n";
      Op.Opcode = "DCINS::GET_REG";
      errs()<<"before add Operand()\n";
      errs()<<" Operand : " <<OpRec->getName()<<"\n";
      errs()<<"before add \n";

      std::string tmp_str_ref = CGI.Namespace.str() + std::string("::") + OpRec->getName().str();
      //Op.addOperand((CGI.Namespace + "::" + OpRec->getName()).getSingleStringRef());
      Op.addOperand(tmp_str_ref);
      errs()<<"after add \n";
      errs()<<"after add Operand()\n";
      errs()<<"before add RESOperand : "<<Op.Opcode<<"\n";
      for(auto i :Op.Operands){
         errs()<<" operand : "<<i<<"\n";
      }
    } else {
      errs()<<"is not sub class of register\n";
      llvm_unreachable("Unknown operand type");
    }
    addResOperand(*Parent, Op);
  }

  /// Make an operation for "implicit" nodes, generate:
  ///   DCINS::IMPLICIT, MVT::isVoid, <imp-def'd Target::Register>
  ///
  void flattenImplicit(const TreePatternNode *TPN, NodeSemantics &NS) {
    NS.Opcode = "DCINS::IMPLICIT";
    for (unsigned i = 0, e = TPN->getNumChildren(); i != e; ++i)
    {
     // NS.addOperand((CGI.Namespace + "::" +
     //               TPN->getChild(i)->getLeafValue()->getAsString()).getSingleStringRef());
      std::string tmp_std_str = CGI.Namespace.str() + std::string("::") + TPN->getChild(i)->getLeafValue()->getAsString();
      NS.addOperand(tmp_std_str);
    }
      
  }

  /// Make node semantics for "set" nodes. For all defined values to be set:
  /// - if the destination is a RegisterClass/RegisterOperand, generate:
  ///     DCINS::PUT_RC, <inferred type>, <MIOperandNo of the reg>, <the value>
  /// - if the destination is an explicit Register, generate:
  ///     DCINS::PUT_REG, <inferred type>, <Target::Register name>, <the value>
  ///
  /// Keep track of the results that were dropped from the SDNode child because
  /// of SDNodeEquiv definitions.
  ///
  void flattenSet(const TreePatternNode *TPN) {
    unsigned NumNodeDefs = TPN->getNumChildren() - 1;
    const TreePatternNode *LastChild = TPN->getChild(TPN->getNumChildren() - 1);

      if (NumNodeDefs != LastChild->getNumTypes()) {
          errs() << "\nFlatten\n";
          errs() << NumNodeDefs << " ";
          TPN->dump();
          errs() << "\n";
          errs() << LastChild->getNumTypes() << " ";
          LastChild->dump();
          errs() << "\n";
//          for (unsigned i = 0; i < LastChild->getNumChildren(); ++i) {
//              errs() << "Num Types: " << LastChild->getChild(i)->getNumTypes() << "\n";
//              errs() << "Type: " << LastChild->getChild(i)->getType(0) << "\n";
//          }
//          errs() << LastChild->getNumChildren() << "\n";
//          errs() << "\n" <<LastChild->getChild(2)->getNumTypes() << "\n";
//          errs() << LastChild->getType(0); TPN->getChild(1)->dump();
          return;
      }
    assert(NumNodeDefs == LastChild->getNumTypes() &&
           "Invalid 'set': last child needs to define all the others.");

    // NS will be thrown away, we just use the def indices of the last child.
    NodeSemantics DummyNS;
    errs()<<"--------\n";
    errs()<<"start to flatten lastchild\n";
    flatten(LastChild, &DummyNS);
    // We count what the child defined, because when replacing equivalent
    // SDNodes, it doesn't define all the children.
    unsigned NumDefs = DummyNS.Operands.size();
    unsigned FirstDefNo = CurDefNo - NumDefs;
    errs()<<"after flatten lastchild\n";
    for (unsigned i = 0, e = NumDefs; i != e; ++i) {
      const TreePatternNode *Child = TPN->getChild(i);
      Record *OpRec = cast<DefInit>(TPN->getChild(i)->getLeafValue())->getDef();

      NodeSemantics NS;
      NS.Types.push_back(MVT::isVoid);

      // RegisterOperands are the same thing as RegisterClasses.
      if (OpRec->isSubClassOf("RegisterOperand"))
        OpRec = OpRec->getValueAsDef("RegClass");

      if (OpRec->isSubClassOf("RegisterClass")) {
        const CGIOperandList::OperandInfo *OpInfo =
            getNamedOperand(Child->getName());
        assert(OpInfo && "'set' output operand not found in instruction?");
        NS.Opcode = "DCINS::PUT_RC";
        NS.Operands.push_back(utostr(OpInfo->MIOperandNo));
      } else if (OpRec->isSubClassOf("Register")) {
        NS.Opcode = "DCINS::PUT_REG";
        std::string tmp_std_str = CGI.Namespace.str() + std::string("::")+ OpRec->getName().str();
        //NS.Operands.push_back((CGI.Namespace + "::" + OpRec->getName()).getSingleStringRef());
        NS.Operands.push_back(tmp_std_str);
      }
      NS.Operands.push_back(utostr(FirstDefNo + i));
      addSemantics(NS);
    }

    // Keep track of the registers removed from the target-specific SDNode.
    for (unsigned i = NumDefs, e = NumNodeDefs; i != e; ++i) {
      assert(TPN->getChild(i)->isLeaf() &&
             "Invalid SDNode equivalence: dropped non-leaf node!");
      Record *OpRec = cast<DefInit>(TPN->getChild(i)->getLeafValue())->getDef();
      assert(OpRec->isSubClassOf("Register") &&
             "Dropped SDNode result isn't an imp-def'd register.");
      EliminatedImplicitRegs.insert(OpRec);
    }
  }

  /// Make node semantics from SDNodes, generate:
  ///   <SDNode opcode>, <inferred types>, <value indices for the operands>
  ///
  /// Also, try to make an equivalence between the SDNode's operator and
  /// one with less results, as defined by the SDNodeEquiv tablegen definitions.
  ///
  void flattenSDNode(const TreePatternNode *TPN, NodeSemantics &NS) {
    Record *Operator = TPN->getOperator();
    errs()<<"flatten sdcode operator : "<<Operator->getName()<<"\n";
    if(TPN->getNumTypes()>0){
        errs()<<"sdnode type 0 : "<<TPN->getSimpleType(0)<<"\n";
    }
    else{
       errs()<<"sdnode type 0 is 0\n ";
    }
    
    SemanticsTarget::SDNodeEquivMap::const_iterator It =
        Target.SDNodeEquiv.find(Operator);
    NS.Opcode = Operator->getValueAsString("Opcode");
    if (It != Target.SDNodeEquiv.end()) {
      Record *EquivNode = It->second;
      const SDNodeInfo &SDNI = Target.CGPatterns.getSDNodeInfo(EquivNode);
      NS.Opcode = SDNI.getEnumName();
      for (unsigned i = 0, e = TPN->getNumTypes() - SDNI.getNumResults();
           i != e; ++i)
        NS.Types.pop_back();
    }
    errs()<<"tpn num children :"<<TPN->getNumChildren()<<"\n";
    for (unsigned i = 0, e = TPN->getNumChildren(); i != e; ++i)
    {
      TreePatternNode *chil_tpn = TPN->getChild(i);
      if(chil_tpn == nullptr){
        errs()<<" child : "<<i<<" is null\n";
      }
      else{
        errs()<<" child : "<<i<<" : \n";//<<chil_tpn->getName()<<"\n";
      }
      flatten(TPN->getChild(i), &NS);
    }
      
  }

  /// Make node semantics for the whole tree \p TPN.
  void flatten(const TreePatternNode *TPN, NodeSemantics *Parent) {
    if (const CGIOperandList::OperandInfo *OpInfo =
            getNamedOperand(TPN->getName())) {
      flattenOperand(TPN, Parent, OpInfo);
      return;
    } else if (TPN->isLeaf()) {
      errs()<<"start to flatten leaf\n";
      flattenLeaf(TPN, Parent);
      return;
    }
    Record *Operator = TPN->getOperator();
    if(Operator == nullptr){
      errs()<<"operator is NULL\n";
    }
   // errs()<<"operator : "<<Operator->getName()<<"\n";
    NodeSemantics NS;

    setNSTypeFromNode(NS, TPN);
    errs()<<"before check\n";
    if (Operator->getName() == "set") {
      errs()<<"is set \n";
      assert(Parent == 0 && "A 'set' node wasn't at the top-level?");
      flattenSet(TPN);
      return;
    }
    if (Operator->getName() == "implicit") {
      assert(Parent == 0 && "An 'implicit' node wasn't at the top-level?");
      errs()<<"start to flatten impicit\n";
      flattenImplicit(TPN, NS);
    } else{ 
      bool result = Operator->isSubClassOf("SDNode");
      errs()<<"result "<<result<<"\n";
      //if (Operator->isSubClassOf("SDNode")==true) {
      if(result != 0){ 
        errs()<<"result :"<<result<<"\n";
      
        if(Operator->getName().equals("store")==true){
          errs()<<"TPN : "<<TPN->getName()<<"\n";
          errs()<<"the operator is store how could that be \n";
          errs()<<"isSubClassOf : "<<Operator->isSubClassOf("SDNode")<<"\n";
          errs()<<"true : "<<true<<"\n";
          auto Superclasses = Operator->getSuperClasses();
          for (auto SCpair : Superclasses){
            if (const auto *SI = dyn_cast<StringInit>(SCpair.first->getNameInit())) {
              errs()<<"si get value : "<<SI->getValue()<<"\n";
              if(SI->getValue() == "SDNode"){
                errs()<<"this equals SDNode? \n";
              }
            }
            else{
              errs()<<"operator super class : "<<SCpair.first->getNameInitAsString()<<"\n";
            }
          }
        }
        errs()<<"start to faltten SDDNode\n";
        errs()<<"flatten node "<<TPN->getName()<<"\n";
        flattenSDNode(TPN, NS);
      } else {
        llvm_unreachable("Unable to handle operator.");
      }
    }
    errs()<<"before secord add\n";
    if (Parent)
      addResOperand(*Parent, NS);
    else
      addSemantics(NS);
    errs()<<"end faltten(tpn 0)\n";
  }

public:
  void flatten(const TreePatternNode *TPN) {
    flatten(TPN, 0);

    // For all the implicit register definitions we dropped because of
    // SDNode equivalences, add an 'implicit' node.
    NodeSemantics NS;
    NS.Opcode = "DCINS::IMPLICIT";
    NS.Types.push_back(MVT::isVoid);
    errs()<<"before addOperand in flatten"<<"\n";
    for (ImplicitRegSet::const_iterator IRI = EliminatedImplicitRegs.begin(),
                                        IRE = EliminatedImplicitRegs.end();
         IRI != IRE; ++IRI) {
      NS.Operands.clear();
      std::string tmp_std_str = CGI.Namespace.str() + std::string("::") + (*IRI)->getName().str();
      //NS.addOperand((CGI.Namespace + "::" + (*IRI)->getName()).getSingleStringRef());
      NS.addOperand(tmp_std_str);
      I.Semantics.push_back(NS);
    }
  }
};

class SemanticsEmitter {
  typedef std::vector<InstSemantics> InstSemaList;

  // List mapping Instruction enum values to indices:
  // - first, index of the semantics in InstSemas
  // - replaced by the start offset in the generated array
  typedef std::vector<unsigned> InstToIdxMap;

  InstSemaList InstSemas;

  InstToIdxMap InstIdx;
  unsigned CurSemaOffset;

  void addInstSemantics(unsigned InstEnumValue, const InstSemantics &Sema);

public:
  SemanticsEmitter(RecordKeeper &Records);

  // run - Output the semantics.
  void run(raw_ostream &OS);

  void ParseSemantics();

  RecordKeeper &Records;
  SemanticsTarget SemaTarget;
  CodeGenDAGPatterns &CGPatterns;
  CodeGenTarget &Target;
};

SemanticsEmitter::SemanticsEmitter(RecordKeeper &Records)
    : InstSemas(), InstIdx(), CurSemaOffset(0), Records(Records),
      SemaTarget(Records), CGPatterns(SemaTarget.CGPatterns),
      Target(SemaTarget.CGTarget) {
  //Records.dump();
  const std::vector<const CodeGenInstruction *> &CGIByEnum =
      Target.getInstructionsByEnumValue();
  InstIdx.resize(CGIByEnum.size());

  // Add dummy semantics.
  addInstSemantics(0, InstSemantics());

  // First, look for Semantics instances.
  ParseSemantics();

  // For the rest, try to use the patterns that are in Instruction instances.
  for (unsigned i = 0, e = CGIByEnum.size(); i != e; ++i) {
    const CodeGenInstruction &CGI = *CGIByEnum[i];
    Record *TheDef = CGI.TheDef;
    const DAGInstruction &DI = CGPatterns.getInstruction(TheDef);
    if (InstIdx[i])
      continue;
    TreePatternNodePtr srcPattern = DI.getSrcPattern();
   // errs()<<"srcPattern : "<<srcPattern->getName()<<"\n";
    if (srcPattern && !CGI.isCodeGenOnly) {
      addInstSemantics(i, InstSemantics(SemaTarget, CGI, *DI.getPattern()));
      TreePattern tmp_Pattern(TheDef,srcPattern,true,CGPatterns);
      //addInstSemantics(i, InstSemantics(SemaTarget, CGI, tmp_Pattern));
    }
  }
}

void SemanticsEmitter::addInstSemantics(unsigned InstEnumValue,
                                        const InstSemantics &Sema) {
  InstIdx[InstEnumValue] = InstSemas.size();
  InstSemas.push_back(Sema);
}

void SemanticsEmitter::ParseSemantics() {
  std::vector<Record *> Instrs = Records.getAllDerivedDefinitions("Semantics");
  const std::vector<const CodeGenInstruction *> &CGIByEnum =
      Target.getInstructionsByEnumValue();
  for (unsigned i=0; i<Instrs.size();i++){
    Record* tmp_record = Instrs[i];
    //tmp_record->getRecords();
  }
  std::map<Record *, DAGInstruction, LessRecordByID> DAGInsts;
  for (unsigned i = 0, e = Instrs.size(); i != e; ++i) {
    ListInit *LI = 0;

    if (isa<ListInit>(Instrs[i]->getValueInit("Pattern")))
      LI = Instrs[i]->getValueAsListInit("Pattern");
    
    Record *InstDef = Instrs[i]->getValueAsDef("Inst");

    CodeGenInstruction &CGI = Target.getInstruction(InstDef);
    //const DAGInstruction &TheInst = CGPatterns.parseInstructionPattern(
     //   CGI, LI, DAGInsts);
     errs()<<"before parse instruction parttern : "<<CGI.AsmString<<"\n";
     errs()<<"CGI the def : "<< CGI.TheDef->getName()<<"\n";
     CGPatterns.parseInstructionPattern(
        CGI, LI, DAGInsts);
      const DAGInstruction &TheInst = DAGInsts.find(InstDef)->second;  //新的接口没有返回值因此需要自己去找
    errs()<<"daginstruction  result "<<TheInst.getNumResults()<<"\n";
    errs()<<"daginstruction  Operands : "<<TheInst.getNumOperands()<<"\n";
    errs()<<"daginstruction   ImpResults :"<<TheInst.getNumImpResults()<<"\n";
    // FIXME: Instead of looking for the instruction *every* time, what about:
    // - iterating on InstructionsByEnumValue, and mapping CGI->Semantics before
    // - adding EnumValue to CGI

    std::vector<const CodeGenInstruction *>::const_iterator It =
        std::find(CGIByEnum.begin(), CGIByEnum.end(), &CGI);
    assert(It != CGIByEnum.end() && *It == &CGI);
    errs()<<"before create treepattern\n";
    TreePattern *tmp_pattern = TheInst.getPattern();
    
    TreePatternNodePtr srcPattern = TheInst.getSrcPattern();
    //errs()<<"The Inst srcPattern"<<srcPattern->getOperator()->getName()<<"\n";
   // TreePattern tmp_pattern(InstDef, srcPattern,true,CGPatterns);
   // errs()<<"src pattern size : "<<tmp_pattern.getNumTrees()<<"\n";
    if(tmp_pattern==nullptr){
       errs()<<"some daginstruction is still null \n";
    }
    else{
       errs()<<"inst def : "<<InstDef->getName()<<"\n";
       errs()<<"pattern size : "<<tmp_pattern->getNumTrees()<<"\n";
       errs()<<"the first pattern : "<<tmp_pattern->getTree(0)->getName()<<"\n";
      if(InstDef->getName().equals("STURXi")){
         errs()<<"first pattern operator : store : "<<
         TheInst.getPattern()->getTree(0)->getOperator()->getName()<<"\n";
      }
    }
    addInstSemantics(std::distance(CGIByEnum.begin(), It),
                     InstSemantics(SemaTarget, CGI, *TheInst.getPattern()));
                      //  InstSemantics(SemaTarget, CGI, tmp_pattern));
  }
}

void SemanticsEmitter::run(raw_ostream &OS) {
  errs()<<"start to write to file \n "<< "\n";
  errs()<<"os buffer size \n "<<OS.GetBufferSize();
  emitSourceFileHeader("Target Instruction Semantics", OS);

  StringRef TGName = Target.getName();
  const std::vector<const CodeGenInstruction *> &CGIByEnum =
      Target.getInstructionsByEnumValue();
  assert(CGIByEnum.size() == InstIdx.size());

  OS << "namespace llvm {\n";

  OS << "namespace " << TGName << " {\n";
  OS << "namespace {\n\n";

  OS << "const unsigned InstSemantics[] = {\n";
  OS << "  DCINS::END_OF_INSTRUCTION,\n";
  errs()<<"start to output instsemantics \n ";
  CurSemaOffset = 1;
  for (unsigned I = 0, E = InstIdx.size(); I != E; ++I) {
    if (InstIdx[I] == 0)
      continue;
    InstSemantics &Sema = InstSemas[InstIdx[I]];
    InstIdx[I] = CurSemaOffset++;
    OS << "  // " << CGIByEnum[I]->TheDef->getName() << "\n";
    for (std::vector<NodeSemantics>::const_iterator SI = Sema.Semantics.begin(),
                                                    SE = Sema.Semantics.end();
         SI != SE; ++SI) {
      ++CurSemaOffset;
      OS.indent(2) << SI->Opcode;
      errs()<<"CGI Def name： "<< CGIByEnum[I]->TheDef->getName()<<"\n";
      errs()<<"si type size ： "<< SI->Types.size()<<"\n";
      errs()<<"si Operand size ： "<< SI->Operands.size()<<"\n";
      errs()<<" I "<< I <<"\n";
      errs()<<" num bytes "<< OS.GetNumBytesInBuffer() <<"\n";
      OS.flush();
      //for (unsigned ti = 0, te = SI->Types.size(); ti != te; ++ti)
      for(unsigned ti=0; ti<SI->Types.size();ti++)
      {
        //errs()<<"ti is "<<ti<<"\n";
        errs()<<"type enum name "<<SI->Types[ti]<<"\n";;
        OS << ", " << llvm::getEnumName(SI->Types[ti]);
        
         
        
      }
      errs()<<"it seems not here 660 \n ";
      CurSemaOffset += SI->Types.size();
      OS.flush();
      //for (unsigned oi = 0, oe = SI->Operands.size(); oi != oe; ++oi)
      for(unsigned oi=0;oi<SI->Operands.size();oi++)
      {
        OS << ", " << SI->Operands[oi];
        errs()<<  ", " << SI->Operands[oi];
        errs()<<"oi is "<<oi<<"\n";
      }
      errs()<<"it seems not here 670\n ";
      CurSemaOffset += SI->Operands.size();
      OS << ",\n";
    }
    OS << "  DCINS::END_OF_INSTRUCTION,\n";
  }
  OS << "};\n\n";
  errs()<<"output Instsemantics \n ";
  OS << "const unsigned OpcodeToSemaIdx[] = {\n";
  for (unsigned I = 0, E = InstIdx.size(); I != E; ++I)
    OS << InstIdx[I] << ", \t// " << CGIByEnum[I]->TheDef->getName() << "\n";
  OS << "};\n\n";
  errs()<<"output OpcodeTosemaidx \n ";
  std::vector<uint64_t> Constants(SemaTarget.ConstantIdx.size() + 1);
  for (SemanticsTarget::ConstantIdxMap::const_iterator
           CI = SemaTarget.ConstantIdx.begin(),
           CE = SemaTarget.ConstantIdx.end();
       CI != CE; ++CI)
    Constants[CI->second] = CI->first;
  OS << "const uint64_t ConstantArray[] = {\n";
  for (unsigned I = 0, E = Constants.size(); I != E; ++I) {
    OS.indent(2) << Constants[I] << "U,\n";
  }
  OS << "};\n\n";
  errs()<<"output sematarget.constantidx \n ";
  OS << "\n} // end anonymous namespace\n";
  OS << "} // end namespace " << TGName << "\n";
  OS << "} // end namespace llvm\n";
}

} // end anonymous namespace

SemanticsTarget::SemanticsTarget(RecordKeeper &Records)
    : Records(Records), CGPatterns(Records),
      CGTarget(CGPatterns.getTargetInfo()), SDNodeEquiv(), ConstantIdx(),
      CurConstIdx(1) {
  errs()<<"start to get equivs\n";
  std::vector<Record *> Equivs =
      Records.getAllDerivedDefinitions("SDNodeEquiv");
  for (unsigned i = 0, e = Equivs.size(); i != e; ++i) {
    SDNodeEquiv[Equivs[i]->getValueAsDef("TargetSpecific")] =
        Equivs[i]->getValueAsDef("TargetIndependent");
  }
}

InstSemantics::InstSemantics(SemanticsTarget &Target,
                             const CodeGenInstruction &CGI,
                             const TreePattern &TP) {
  errs()<<"at start of instsemantics \n";
  Flattener Flat(Target, CGI, *this);
  for (unsigned i = 0, e = TP.getNumTrees(); i != e; ++i)
  {
    if(TP.getTree(i)==nullptr){
      errs()<<"num :"<<i<<" is null\n";
    }
    errs()<<" num : "<<i<<" is "<<TP.getTree(i)->getOperator()->getName()<<"\n";
    Flat.flatten(TP.getTree(i).get());
  }
    
}

InstSemantics::InstSemantics() {
  NodeSemantics NS;
  NS.Opcode = "DCINS::END_OF_INSTRUCTION";
  Semantics.push_back(NS);
}

namespace llvm {

bool EmitSemantics(RecordKeeper &Records, raw_ostream &OS) {
  errs()<<"start to emit semantics \n ";
  SemanticsEmitter(Records).run(OS);
  errs()<<"end to emit semantics \n ";
  return false;
}

} // end namespace llvm
